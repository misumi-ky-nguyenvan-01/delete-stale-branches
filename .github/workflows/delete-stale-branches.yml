name: Delete stale branches (One Fetch)
on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'true ã®å ´åˆã€å®Ÿéš›ã«ã¯ãƒ–ãƒ©ãƒ³ãƒã‚’å‰Šé™¤ã—ã¾ã›ã‚“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: trueï¼‰'
        required: false
        default: 'true'
      max_deletions:
        description: 'ä¸€åº¦ã®å®Ÿè¡Œã§å‰Šé™¤ã™ã‚‹æœ€å¤§ãƒ–ãƒ©ãƒ³ãƒæ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 50ï¼‰'
        required: false
        default: '50'
      diff_or_date:
        description: 'æœ€çµ‚ã‚³ãƒŸãƒƒãƒˆã‹ã‚‰ã®çµŒéæ—¥æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 90ï¼‰'
        required: false
        default: '90'

jobs:
  delete-stale-branches:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo
            const fs = require('fs')
            const path = require('path')

            const LOG_FILE_PATH = path.join(process.cwd(), 'logs', 'deleted-branches.log')
            const logDir = path.dirname(LOG_FILE_PATH)
            if (!fs.existsSync(logDir)) fs.mkdirSync(logDir, { recursive: true })
            
            const DIFF_OR_DATE = parseInt(core.getInput('diff_or_date'))
            const MAX_DELETIONS = parseInt(core.getInput('max_deletions'))
            const DRY_RUN = core.getInput('dry_run') === 'true'

            const branchPatterns = [
              { prefix: 'feature/', requireClosedPR: true },
              { prefix: 'test/', requireClosedPR: false },
              { prefix: 'release/', requireClosedPR: false },
              { prefix: 'revert-', requireClosedPR: true }
            ]


            async function fetchAllBranches() {
              let hasNextPage = true
              let endCursor = null
              let allBranches = []

              while (hasNextPage) {
                const query = `
                  query($owner: String!, $repo: String!, $cursor: String) {
                    repository(owner: $owner, name: $repo) {
                      refs(refPrefix: "refs/heads/", first: 100, after: $cursor) {
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                        nodes {
                          name
                          target {
                            ... on Commit { committedDate }
                          }
                        }
                      }
                    }
                  }
                `

                const result = await github.graphql(query, { owner, repo, cursor: endCursor })
                const refs = result.repository.refs
                const branches = refs.nodes

                const batch = branches.map(branch => ({
                  name: branch.name,
                  lastCommitDate: new Date(branch.target.committedDate)
                }))

                allBranches.push(...batch)

                hasNextPage = refs.pageInfo.hasNextPage
                endCursor = refs.pageInfo.endCursor
              }

              return allBranches
            }

            let allBranches = []

            try {
              allBranches = await fetchAllBranches()
            } catch (error) {
              console.error(`Error fetching branches: ${error.message}`)
              process.exit(1)
            }
            console.log(`å–å¾—ã—ãŸãƒ–ãƒ©ãƒ³ãƒç·æ•°: ${allBranches.length}`)

            let branchesToDelete = []
            const patternStats = {}

            for (const pattern of branchPatterns) {
              const matched = allBranches.filter(branch => branch.name.startsWith(pattern.prefix))
              patternStats[pattern.prefix] = matched.length

              const mapped = matched.map(branch => ({
                name: branch.name,
                lastCommitDate: branch.lastCommitDate,
                requireClosedPR: pattern.requireClosedPR,
                pattern: pattern.prefix
              }))

              branchesToDelete.push(...mapped)

              console.log(`ãƒ‘ã‚¿ãƒ¼ãƒ³ "${pattern.prefix}": ${matched.length} ãƒ–ãƒ©ãƒ³ãƒ`)
              console.log(`æœ€åˆã®ãƒ–ãƒ©ãƒ³ãƒ: ${matched[0]?.name || 'ãªã—'}`)
            }

            console.log(`å‰Šé™¤å¯¾è±¡ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ–ãƒ©ãƒ³ãƒç·æ•°: ${branchesToDelete.length}`)

            async function isDeletableBranch(branchName) {
              const { data: pullRequests } = await github.rest.pulls.list({
                owner,
                repo,
                head: `${owner}:${branchName}`,
                state: 'all'
              })
              if (pullRequests.length === 0) return true
              return pullRequests.every(pr => pr.state === 'closed' || pr.state === 'merged')
            }

            let totalDeleted = 0
            let totalSkipped = 0

            for (const branch of branchesToDelete) {
              const daysSince = Math.floor((Date.now() - branch.lastCommitDate.getTime()) / (1000 * 60 * 60 * 24))

              if (daysSince < DIFF_OR_DATE) {
                console.log(`â© ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæœ€è¿‘ã®ã‚³ãƒŸãƒƒãƒˆï¼‰: ${branch.name} (${daysSince}æ—¥å‰)`)
                totalSkipped++
                continue
              }

              let canDelete = true
              if (branch.requireClosedPR) {
                canDelete = await isDeletableBranch(branch.name)
              }

              if (!canDelete) {
                console.log(`ğŸš« ã‚¹ã‚­ãƒƒãƒ—ï¼ˆPRé–‹æ”¾ä¸­ï¼‰: ${branch.name}`)
                totalSkipped++
                continue
              }

              try {
                if (DRY_RUN) {
                  console.log(` [DRY-RUN] å‰Šé™¤å¯¾è±¡: ${branch.name}`)
                } else {
                  await github.rest.git.deleteRef({ owner, repo, ref: `heads/${branch.name}` })
                  const deletionLog = `${branch.name} - å‰Šé™¤æ—¥: ${new Date().toISOString()}\n`
                  fs.appendFileSync(LOG_FILE_PATH, deletionLog)
                }

                console.log(`âœ… å‰Šé™¤å®Œäº†: ${branch.name} (${daysSince}æ—¥å‰)`)
                totalDeleted++

                if (totalDeleted >= MAX_DELETIONS) {
                  console.log(`æœ€å¤§å‰Šé™¤æ•° ${MAX_DELETIONS} ã«é”ã—ã¾ã—ãŸã€‚çµ‚äº†ã—ã¾ã™ã€‚`)
                  console.log(`æ®‹ã‚Š ${branchesToDelete.length - (branchesToDelete.indexOf(branch) + 1)} ãƒ–ãƒ©ãƒ³ãƒã¯æ¬¡å›å®Ÿè¡Œæ™‚ã«å‰Šé™¤ã•ã‚Œã¾ã™`)
                  break
                }
              } catch (err) {
                console.log(`âŒ å‰Šé™¤å¤±æ•—: ${branch.name} (${err.message})`)
                totalSkipped++
              }
            }

            console.log('æ¦‚è¦:')
            for (const [pattern, count] of Object.entries(patternStats)) {
              console.log(`- ${pattern.padEnd(10)}: ${count} ãƒ–ãƒ©ãƒ³ãƒ`)
            }
            console.log(`æ¦‚è¦: âœ… å‰Šé™¤=${totalDeleted}ã€â© ã‚¹ã‚­ãƒƒãƒ—=${totalSkipped}`)
